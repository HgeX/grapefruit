package grapefruit.command.util;

import grapefruit.command.CommandException;
import grapefruit.command.argument.FlagArgument;
import grapefruit.command.argument.binding.BoundArgument;
import grapefruit.command.dispatcher.UnrecognizedFlagException;
import grapefruit.command.dispatcher.syntax.CommandSyntax;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.function.Supplier;

import static java.util.Objects.requireNonNull;

/**
 * A utility class to make it simpler to detect flags and
 * flag groups in the provided command line.
 */
public class FlagGroup implements Iterable<BoundArgument<?>> {
    private final List<BoundArgument<?>> arguments;

    private FlagGroup(List<BoundArgument<?>> arguments) {
        this.arguments = requireNonNull(arguments, "arguments cannot be null");
    }

    /**
     * Attempts to parse an arbitrary input into a list of flags. The supplied
     * argument list is assumed to only contain flag arguments.
     *
     * @param input The input
     * @param candidates A list of potential flag arguments
     * @return An optional containing the created flag group, or
     * an empty optional, if the input was not a valig flag/flag group.
     */
    public static Optional<FlagGroup> attemptParse(String input, List<BoundArgument<?>> candidates) throws CommandException {
        /*
         * If the input isn't even 2 characters long or doesn't start with
         * '-', it's not a flag group.
         */
        if (input.length() < 2 || input.charAt(0) != CommandSyntax.SHORT_FLAG_PREFIX_CH) return Optional.empty();

        /*
         * This means the input is prefixed with '--' , it's either a long
         * flag name, or '--' literally.
         */
        if (input.charAt(1) == CommandSyntax.SHORT_FLAG_PREFIX_CH) {
            // The input is literally '--' , which is not a valid flag group, returning.
            if (input.length() == 2) return Optional.empty();

            // Long flag name, extract it
            String flagName = input.substring(2);
            // Attempt to find a flag with the extracted name. Throw unrecognized flag
            // exception, if none was found.
            FlagGroup group = new FlagGroup(List.of(selectFlag(
                    candidates,
                    x -> x.name().equals(flagName),
                    () -> new UnrecognizedFlagException(flagName)
            )));

            return Optional.of(group);
        } else {
            // We either have a single shorthand or a group of shorthands.
            char[] shorthands = input.substring(1).toCharArray();
            List<BoundArgument<?>> flags = new ArrayList<>();

            // Find flags by their shorthands
            for (char c : shorthands) {
                /*
                 * Flag shorthands are expected to be alphabetic. If this
                 * argument is not, it isn't a flag shorthand either, thus
                 * we return an empty optional.
                 */
                if (!Character.isAlphabetic(c)) return Optional.empty();

                flags.add(selectFlag(
                        candidates,
                        x -> x.shorthand() == c,
                        // Throw an exception, because an unrecognized flag shorthand was provided
                        () -> new UnrecognizedFlagException(c)
                ));
            }

            FlagGroup group = new FlagGroup(flags);
            return Optional.of(group);
        }
    }

    /**
     * Selects a single {@link BoundArgument} from the provided list of
     * flags based on the supplied predicate, or throws an exception
     * generated by the provided exception factory.
     *
     * @param candidates The potential flags
     * @param test The condition to match
     * @param exceptionFactory Generator for the exception to be thrown
     * @return The selected flag argument
     */
    private static BoundArgument<?> selectFlag(
            List<BoundArgument<?>> candidates,
            Predicate<FlagArgument<?>> test,
            Supplier<CommandException> exceptionFactory
    ) throws CommandException {
        return candidates.stream().filter(x -> test.test(x.argument().asFlag()))
                .findFirst()
                .orElseThrow(exceptionFactory);
    }

    @Override
    public @NotNull Iterator<BoundArgument<?>> iterator() {
        return this.arguments.iterator();
    }
}
