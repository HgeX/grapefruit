- Command call listeners existed in grapefruit 1, I'd like to have them in this version too, maybe
  having more stages to register call listeners to. Maybe [ PRE_PARSE, PRE_EXECUTION, POST_EXECUTION, FAILED ].
  Unlike the first version, this time they could actually get access to the current CommandContext
  instance as that's already created when CommandDispatcher#dispatch is called. The registration shall
  happen in DispatcherConfigurer as that's where every bit of configuration is done.

- Add more documentation.

- Add tests.

- Message system? Right now we don't have one, and I'm actually glad about that. We do throw a lot
  of exceptions though that are up to the user to handle, but right now I think that works. Probably
  in the long run too. Maybe we could have an extension package to grapefruit, and that could take
  care of printing the appropriate messages to users based on exceptions. Maybe. If not, then we'll
  need to have a lot more flexible message system than what was implemented in grapefruit 1.

- Implement "standard" argument mappers for java primitive types (maybe not boolean though, because
  please use presence flags instead?), and perhaps a few other builtin java types (such types could
  be UUID, Duration, some form of Date (maybe the newer LocalDateTime thingy instead).
  - A so-called CommaSeparatedArgumentMapper would also make sense. It would expect arguments formatted as a,b,c,
    and then map them into a List, or Set, or whatever. It could look something like this:
    ArgumentMapper<Set<MyType>> mapper = CommaSeparatedArgumentMapper.wrap(new MyTypeMapper(), HashSet::new);
    It could also come with multiple factory methods, such as #set (returning a set of something), #list
    (returning a list of something) with #wrap allowing users to pass in a generator, should they want
    something different.
  - EnumLikeArgumentMapper could take a list of arguments and only accept those (T[]). For instance, a
    weekday mapper would be something like: ArgumentMapper<String> weekdayMapper = EnumLikeArgumentMapper.of("monday", "tuesday"...);


- Introduce description system. @CommandDefinition, @Arg, and @Flag annotations should have a "description"
  parameter ("" by default), and if a command syntax exception is thrown, these descriptions should be included
  so that they can be printed to the user. Optionally, we might want to have description lookup/provider system,
  which could be used for the localization of descriptions.

- Configurable "man" command or "--help -h -?" flags for printing command and argument descriptions as
  well as the correct command syntax.

- Investigate if having a @Suggestions(String[]) annotation to provide custom suggestions for a command
  argument is a good idea. Maybe it is, maybe it isn't.

- Returning a result from a command handler could be cool. Generate code so that if the annotated method's return type
  isn't void, we store the result in the correct command context mapped to COMMAND_RESULT_KEY or something.

- [23:36:10 WARN]: com.tomushimano.lib.command.dispatcher.CommandInvocationException: java.lang.NullPointerException: Cannot invoke "java.lang.Integer.intValue()" because the return value of "com.tomushimano.lib.command.dispatcher.CommandContext.nullable(com.tomushimano.lib.command.util.key.Key)" is null
  \_ Fix that!

- Codegen module: collectRelevantAnnotations (per parameter)

- [code-gen]: See what happens, if nested classes have command methods in them. They probably work fine, but the container class will be
  named after the original class's parent class, so if we have command methods in both the parent and nested class, the container names
  will clash.

- [core]: Rework command syntax system.
- [core]: Get rid of some of the exception classes, if possible.

- [code-gen]: Execution failed for task ':foundation-plugin:compileJava'.
              > java.lang.IllegalArgumentException: not a valid name: display-name_java_lang_String_key
              ^ FIX THIS

- [code-gen]: Store command set as a private final field, and just return an immutable copy of it whenever #commands is called
- [code-gen]: Add a name cache, so we can detect names that would clash. Right now sanitization would turn both 'ab:c' and 'ab-c' into 'ab_c',
  which could cause issues later. We would need to somehow keep track of parameter names, types and key name.
