- @InjectedBy annotation. At the moment non-argument parameters are allowed, but only
  one per type. So if a command method has the following parameters: (String x, @Arg int y, @Arg int z),
  we assume that a value for x will be in the context store mapped to Key.of(String). This
  doesn't allow us to inject multiple arguments of type String. I'm unsure if this is a problem
  or not, the only use-case I can think of right now is minecraft command senders. Or
  perhaps command cost values and stuff like that. But still, maybe having a similar system
  to the mapped by stuff described above would make sense. Let's say we create a new annotation
  called @InjectedBy(String) (not @Inject as that would conflict with DI frameworks), the string
  argument would refer to a key name, and then we could either annotate a parameter or an
  annotation with this. So if maybe we have a cost modifier on our command (minecraft...), we
  could inject it into the function either by (...params, @InjectedBy("__command_cost__") float cost), or
  (...params, @Cost float cost), assuming that @Cost itself is annotated with @InjectedBy("__command_cost__").
  And while we're at it, we could also set the nullability of the value to be injected, so that
  the appropriate command context method is used. something like: @InjectedBy(value = "something", nullable = true);
  the field "nullable" could be false by default (in which case CommandContext#require is used, otherwise
  CommandContext#nullable).

- Command call listeners existed in grapefruit 1, I'd like to have them in this version too, maybe
  having more stages to register call listeners to. Maybe [ PRE_PARSE, PRE_EXECUTION, POST_EXECUTION, FAILED ].
  Unlike the first version, this time they could actually get access to the current CommandContext
  instance as that's already created when CommandDispatcher#dispatch is called. The registration shall
  happen in DispatcherConfigurer as that's where every bit of configuration is done.

- RoutePart should probably be extracted from CommandGraph and should live in CommandSpec instead.
  This way we would only need to parse the route once, when the spec is created, the graph could
  already access it when the #insert method is called, and could access it again when #delete
  is called (right now it needs to parse the route again, which is suboptimal). This way registration
  handlers could also operate on the processed route parts as opposed to the raw string
  representation, which would simplify registering commands on third party platforms.

- Add more documentation.

- Add tests.

- Message system? Right now we don't have one, and I'm actually glad about that. We do throw a lot
  of exceptions though that are up to the user to handle, but right now I think that works. Probably
  in the long run too. Maybe we could have an extension package to grapefruit, and that could take
  care of printing the appropriate messages to users based on exceptions. Maybe. If not, then we'll
  need to have a lot more flexible message system than what was implemented in grapefruit 1.

- Implement "standard" argument mappers for java primitive types (maybe not boolean though, because
  please use presence flags instead?), and perhaps a few other builtin java types (such types could
  be UUID, Duration, some form of Date (maybe the newer LocalDateTime thingy instead).
  - A so-called CommaSeparatedArgumentMapper would also make sense. It would expect arguments formatted as a,b,c,
    and then map them into a List, or Set, or whatever. It could look something like this:
    ArgumentMapper<Set<MyType>> mapper = CommaSeparatedArgumentMapper.wrap(new MyTypeMapper(), HashSet::new);
    It could also come with multiple factory methods, such as #set (returning a set of something), #list
    (returning a list of something) with #wrap allowing users to pass in a generator, should they want
    something different.
  - An enum mapper would also be nice. It could have several configuration options, such as whether
    case-insensitivity is desired or not, what values should be accepted (EnumSet.of()).
  - EnumLikeArgumentMapper could take a list of arguments and only accept those (T[]). For instance, a
    weekday mapper would be something like: ArgumentMapper<String> weekdayMapper = EnumLikeArgumentMapper.of("monday", "tuesday"...);


- Introduce description system. @CommandDefinition, @Arg, and @Flag annotations should have a "description"
  parameter ("" by default), and if a command syntax exception is thrown, these descriptions should be included
  so that they can be printed to the user. Optionally, we might want to have description lookup/provider system,
  which could be used for the localization of descriptions.

- Configurable "man" command or "--help -h -?" flags for printing command and argument descriptions as
  well as the correct command syntax.

- Investigate if having a @Suggestions(String[]) annotation to provide custom suggestions for a command
  argument is a good idea. Maybe it is, maybe it isn't.

- Returning a result from a command handler could be cool. Generate code so that if the annotated method's return type
  isn't void, we store the result in the correct command context mapped to COMMAND_RESULT_KEY or something.

- [23:36:10 WARN]: com.tomushimano.lib.command.dispatcher.CommandInvocationException: java.lang.NullPointerException: Cannot invoke "java.lang.Integer.intValue()" because the return value of "com.tomushimano.lib.command.dispatcher.CommandContext.nullable(com.tomushimano.lib.command.util.key.Key)" is null
  \_ Fix that!

- Codegen module: collectRelevantAnnotations (per parameter)

- [code-gen]: See what happens, if nested classes have command methods in them. They probably work fine, but the container class will be
  named after the original class's parent class, so if we have command methods in both the parent and nested class, the container names
  will clash.
